#!/usr/bin/env python3
"""
Builds `app/src/wordlists-curated.js` for the static Wordle helper.

Source-of-truth:
  - Optional curated answers: `app/wordlists/answers-{L}.txt`
  - Optional curated guesses: `app/wordlists/guesses-{L}.txt`
Fallbacks:
  - If guesses-{L}.txt is missing, use /usr/share/dict/words (a-z only)
  - If answers-{L}.txt is missing (and L != 5), fall back to the guess list
  - 5-letter answers remain in `app/src/wordlist.js` (WORD_LIST / WORD_LISTS[5])
"""

from __future__ import annotations

import argparse
import json
import re
from pathlib import Path


RE_WORD = re.compile(r"^[a-z]+$")
RE_ALPHA = re.compile(r"^[A-Za-z]+$")
DEFAULT_DICT = Path("/usr/share/dict/words")
LENGTHS = (3, 4, 5, 6, 7)


def read_word_file(path: Path, length: int) -> list[str]:
    if not path.exists():
        return []
    seen: set[str] = set()
    out: list[str] = []
    for line in path.read_text(encoding="utf-8").splitlines():
        word = line.strip().lower()
        if not word:
            continue
        if len(word) != length:
            continue
        if not RE_WORD.match(word):
            continue
        if word in seen:
            continue
        seen.add(word)
        out.append(word)
    return out


def read_dict_words(path: Path, length: int) -> list[str]:
    seen: set[str] = set()
    out: list[str] = []
    with path.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            raw = line.strip()
            if len(raw) != length:
                continue
            # Include capitalized dictionary entries by lowercasing and deduping.
            # (The word list strategy is controlled by what you feed into wordlists/*.txt;
            # the /usr/share/dict fallback should not silently drop valid spellings.)
            if not RE_ALPHA.match(raw):
                continue
            word = raw.lower()
            if not RE_WORD.match(word):
                continue
            if word in seen:
                continue
            seen.add(word)
            out.append(word)
    out.sort()
    return out


def js_assign(name: str, idx: int, words: list[str]) -> str:
    # Compact JSON array is fine; browser parses quickly and keeps file small.
    return f"  {name}[{idx}] = {json.dumps(words, separators=(',', ':'))};"


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--dict",
        type=Path,
        default=DEFAULT_DICT,
        help="Dictionary path for fallback guess lists (default: /usr/share/dict/words)",
    )
    parser.add_argument(
        "--out",
        type=Path,
        default=None,
        help="Output JS file (default: app/src/wordlists-curated.js)",
    )
    args = parser.parse_args()

    app_dir = Path(__file__).resolve().parents[1]
    wordlists_dir = app_dir / "wordlists"
    out_path = args.out or (app_dir / "src" / "wordlists-curated.js")

    wordlists_dir.mkdir(parents=True, exist_ok=True)

    guess_lists: dict[int, list[str]] = {}
    answer_lists: dict[int, list[str]] = {}

    for L in LENGTHS:
        guesses_path = wordlists_dir / f"guesses-{L}.txt"
        answers_path = wordlists_dir / f"answers-{L}.txt"

        guesses = read_word_file(guesses_path, L)
        if not guesses:
            if args.dict.exists():
                guesses = read_dict_words(args.dict, L)
            else:
                guesses = []
        guess_lists[L] = guesses

        answers = read_word_file(answers_path, L)
        if not answers and L != 5:
            answers = guesses
        if answers:
            answer_lists[L] = answers

    lines: list[str] = []
    lines.append("// Generated by tools/build_wordlists.py")
    lines.append("(function(){")
    lines.append("  if (typeof window === 'undefined') return;")
    lines.append("  window.WORD_LISTS = window.WORD_LISTS || {};")
    lines.append("  window.GUESS_LISTS = window.GUESS_LISTS || {};")
    lines.append("  const WORD_LISTS = window.WORD_LISTS;")
    lines.append("  const GUESS_LISTS = window.GUESS_LISTS;")

    for L in LENGTHS:
        guesses = guess_lists.get(L, [])
        if not guesses:
            continue
        # 5-letter guesses default to the same pool as WORD_LISTS[5] (from src/wordlist.js),
        # unless guesses-5.txt is explicitly provided.
        if L == 5 and not (wordlists_dir / "guesses-5.txt").exists():
            continue
        lines.append(js_assign("GUESS_LISTS", L, guesses))

    for L in sorted(answer_lists.keys()):
        # Avoid overriding 5-letter answers unless explicitly provided via answers-5.txt.
        if L == 5:
            lines.append(f"  // answers-5.txt present: override WORD_LISTS[5]")
            lines.append(js_assign("WORD_LISTS", L, answer_lists[L]))
            continue
        lines.append(js_assign("WORD_LISTS", L, answer_lists[L]))

    lines.append("})();")
    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

    meta = {
        "out": str(out_path),
        "guesses": {str(L): len(guess_lists[L]) for L in LENGTHS},
        "answers": {str(L): len(answer_lists.get(L, [])) for L in LENGTHS},
    }
    print(json.dumps(meta, indent=2))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
